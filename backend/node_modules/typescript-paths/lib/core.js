'use strict';

var Module = require('module');
var path = require('path');
var ts = require('typescript');
var fs = require('fs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Module__default = /*#__PURE__*/_interopDefaultLegacy(Module);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var ts__default = /*#__PURE__*/_interopDefaultLegacy(ts);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

exports.LogLevel = void 0;

(function (LogLevel) {
  LogLevel[LogLevel["None"] = 0] = "None";
  LogLevel[LogLevel["Error"] = 1] = "Error";
  LogLevel[LogLevel["Warning"] = 2] = "Warning";
  LogLevel[LogLevel["Info"] = 3] = "Info";
  LogLevel[LogLevel["Debug"] = 4] = "Debug";
  LogLevel[LogLevel["Trace"] = 5] = "Trace";
})(exports.LogLevel || (exports.LogLevel = {}));

function convertLogLevel(level) {
  switch (level) {
    case "none":
      return exports.LogLevel.None;

    case "error":
      return exports.LogLevel.Error;

    case "warn":
      return exports.LogLevel.Warning;

    case "info":
      return exports.LogLevel.Info;

    case "debug":
      return exports.LogLevel.Debug;

    case "trace":
      return exports.LogLevel.Trace;

    default:
      return undefined;
  }
}
const Reset = "\x1b[0m";
const FgRed = "\x1b[31m";
const FgYellow = "\x1b[33m";
const FgBlue = "\x1b[34m";
const FgCyan = "\x1b[36m";
const FgMagenta = "\x1b[35m";
function fromTYPESCRIPT_PATHS_LOG_LEVEL() {
  const env = process.env["TYPESCRIPT_PATHS_LOG_LEVEL"];

  switch (env) {
    case "none":
      return exports.LogLevel.None;

    case "error":
      return exports.LogLevel.Error;

    case "warn":
      return exports.LogLevel.Warning;

    case "info":
      return exports.LogLevel.Info;

    case "debug":
      return exports.LogLevel.Debug;

    case "trace":
      return exports.LogLevel.Trace;

    default:
      return undefined;
  }
}
function createLogger({
  logLevel = fromTYPESCRIPT_PATHS_LOG_LEVEL() || exports.LogLevel.Info,
  colors = true,
  ID = "typescript-paths"
} = {}) {
  return function log(level, ...args) {
    if (logLevel < level) {
      return;
    }

    if (ID) {
      args.unshift(`[${ID}]:`);
    }

    if (colors) {
      args = args.map(a => {
        if (typeof a !== "string") return a;

        switch (level) {
          case exports.LogLevel.Error:
            return FgRed + a + Reset;

          case exports.LogLevel.Warning:
            return FgYellow + a + Reset;

          case exports.LogLevel.Info:
            return FgBlue + a + Reset;

          case exports.LogLevel.Debug:
            return FgCyan + a + Reset;

          case exports.LogLevel.Trace:
            return FgMagenta + a + Reset;
        }
      });
    }

    switch (level) {
      case exports.LogLevel.Error:
        console.error(...args);
        break;

      case exports.LogLevel.Warning:
        console.warn(...args);
        break;

      case exports.LogLevel.Info:
        console.info(...args);
        break;

      case exports.LogLevel.Debug:
        console.log(...args);
        break;

      case exports.LogLevel.Trace:
        console.log(...args);
        break;
    }
  };
}

function getTsConfig({
  tsConfigPath,
  log = createLogger(),
  host = ts__default["default"].sys
}) {
  const {
    error,
    config
  } = ts__default["default"].readConfigFile(tsConfigPath, host.readFile);

  if (error) {
    let hasError = false;

    switch (error.category) {
      case ts__default["default"].DiagnosticCategory.Error:
        log(exports.LogLevel.Error, error.messageText);
        hasError = true;
        break;
    }

    if (hasError) return undefined;
  }

  let {
    options: compilerOptions,
    errors,
    fileNames,
    projectReferences
  } = ts__default["default"].parseJsonConfigFileContent(config, host, path__default["default"].resolve(path__default["default"].dirname(tsConfigPath)));

  if (errors.length > 0) {
    let hasError = false;

    for (const error of errors) {
      switch (error.category) {
        case ts__default["default"].DiagnosticCategory.Error:
          log(exports.LogLevel.Error, error.messageText);
          hasError = true;
          break;
      }
    }

    if (hasError) return undefined;
  }

  const ret = {
    compilerOptions,
    fileNames: fileNames.map(path__default["default"].normalize)
  };

  if (projectReferences) {
    ret.references = [];

    for (const r of projectReferences) {
      let tsConfigPath = r.path;

      try {
        const stat = fs__default["default"].lstatSync(tsConfigPath);

        if (stat.isDirectory()) {
          tsConfigPath = path__default["default"].join(tsConfigPath, "tsconfig.json");
        }
      } catch (err) {
        const error = err;
        log(exports.LogLevel.Error, error.message);
        return undefined;
      }

      const cfg = getTsConfig({
        tsConfigPath,
        log,
        host
      });
      if (cfg) ret.references.push(cfg);
    }
  }

  return ret;
}
function createMappings({
  paths,
  log = createLogger(),
  respectCoreModule = true
}) {
  const countWildcard = value => {
    var _value$match;

    return ((_value$match = value.match(/\*/g)) === null || _value$match === void 0 ? void 0 : _value$match.length) ?? 0;
  };

  const mappings = [];

  for (const pattern of Object.keys(paths)) {
    if (countWildcard(pattern) > 1) {
      log(exports.LogLevel.Warning, `Pattern '${pattern}' can have at most one '*' character.`);
      continue;
    }

    const wildcard = pattern.indexOf("*");

    if (respectCoreModule) {
      let skip = false;

      for (const key of Module.builtinModules) {
        if (pattern === key || pattern.startsWith(key + "/")) {
          log(exports.LogLevel.Warning, `path pattern '${pattern}' is ignored.`);
          log(exports.LogLevel.Info, `respect core module '${key}'.`);
          skip = true;
        }
      }

      if (skip) continue;
    }

    const targets = paths[pattern].filter(target => {
      if (countWildcard(target) > 1) {
        log(exports.LogLevel.Warning, `Substitution '${target}' in pattern '${pattern}' can have at most one '*' character.`);
        return false;
      }

      return true;
    });

    if (targets.length === 0) {
      continue;
    }

    if (pattern === "*") {
      mappings.push({
        wildcard: true,
        pattern,
        prefix: "",
        suffix: "",
        targets
      });
      continue;
    }

    mappings.push({
      wildcard: wildcard !== -1,
      pattern,
      prefix: pattern.substring(0, wildcard),
      suffix: pattern.substring(wildcard + 1),
      targets
    });
  }

  for (const mapping of mappings) {
    log(exports.LogLevel.Debug, `pattern: '${mapping.pattern}' targets: '${mapping.targets}'`);
  }

  return mappings;
}
function isPatternMatch(prefix, suffix, candidate) {
  return candidate.length >= prefix.length + suffix.length && candidate.startsWith(prefix) && candidate.endsWith(suffix);
}
function findMatch(moduleName, mappings) {
  let longestMatchedPrefixLength = -1;
  let matched;

  for (const mapping of mappings) {
    const {
      wildcard,
      prefix,
      suffix,
      pattern
    } = mapping;

    if (wildcard && isPatternMatch(prefix, suffix, moduleName)) {
      if (longestMatchedPrefixLength < prefix.length) {
        longestMatchedPrefixLength = prefix.length;
        matched = mapping;
      }
    } else if (moduleName === pattern) {
      matched = mapping;
      break;
    }
  }

  return matched;
}
function resolveModuleName({
  mappings,
  request,
  importer,
  compilerOptions,
  host,
  falllback
}) {
  const matched = findMatch(request, mappings);

  if (!matched) {
    return undefined;
  }

  const matchedWildcard = request.slice(matched.prefix.length, request.length - matched.suffix.length);

  for (const target of matched.targets) {
    const updated = matched.wildcard ? target.replace("*", matchedWildcard) : target;
    const base = compilerOptions.baseUrl ?? compilerOptions.pathsBasePath;
    const moduleName = path__default["default"].resolve(base, updated);
    const ext = path__default["default"].extname(moduleName);

    switch (ext) {
      case ".ts":
      case ".tsx":
      case ".json":
        return moduleName;

      case ".js":
      case ".jsx":
        if (compilerOptions.module === ts__default["default"].ModuleKind.NodeNext) {
          break;
        }

        return moduleName;
    }

    const result = ts__default["default"].resolveModuleName(moduleName, importer, compilerOptions, host);

    if (result !== null && result !== void 0 && result.resolvedModule) {
      return path__default["default"].normalize(result.resolvedModule.resolvedFileName);
    }

    if (falllback !== null && falllback !== void 0 && falllback(moduleName)) return moduleName;
  }

  return undefined;
}

function fromTS_NODE_PROJECT() {
  const env = process.env["TS_NODE_PROJECT"];
  if (env) return env.split(path__default["default"].delimiter).filter(Boolean);
  return undefined;
}
function createHandler({
  searchPath,
  tsConfigPath = fromTS_NODE_PROJECT(),
  respectCoreModule = true,
  log = createLogger(),
  falllback
} = {}) {
  if (!tsConfigPath) {
    if (searchPath && searchPath instanceof Array) {
      tsConfigPath = searchPath.map(p => ts__default["default"].findConfigFile(p, ts__default["default"].sys.fileExists)).filter(v => Boolean(v));
    } else {
      tsConfigPath = ts__default["default"].findConfigFile(searchPath || ts__default["default"].sys.getCurrentDirectory(), ts__default["default"].sys.fileExists) || [];
    }
  }

  const services = [];

  if (typeof tsConfigPath === "string") {
    tsConfigPath = [tsConfigPath];
  } else if (!(tsConfigPath instanceof Array)) {
    tsConfigPath = [tsConfigPath];
  }

  function addServices(config) {
    const {
      compilerOptions,
      fileNames,
      references
    } = config;
    if (!compilerOptions.paths || compilerOptions.paths instanceof Array) return;
    services.push({
      compilerOptions,
      fileNames,
      mappings: createMappings({
        log,
        respectCoreModule,
        paths: compilerOptions.paths
      }),
      cache: new Map()
    });

    if (references) {
      for (const config of references) {
        addServices(config);
      }
    }
  }

  for (const configPayloadOrPath of tsConfigPath) {
    if (typeof configPayloadOrPath === "string") log(exports.LogLevel.Trace, `loading: ${configPayloadOrPath}`);
    const config = typeof configPayloadOrPath === "string" ? getTsConfig({
      tsConfigPath: configPayloadOrPath,
      host: ts__default["default"].sys,
      log
    }) : configPayloadOrPath;
    if (!config) return undefined;
    addServices(config);
  }

  const host = { ...ts__default["default"].sys,

    fileExists(filename) {
      if (filename.endsWith(ts__default["default"].Extension.Dts)) return false;
      return ts__default["default"].sys.fileExists(filename);
    }

  };
  return (request, importer) => services.reduce((result, srv) => {
    if (result) {
      return result;
    }

    const {
      compilerOptions,
      cache,
      fileNames,
      mappings
    } = srv;
    const exist = cache.get(importer);

    if (exist !== undefined) {
      cache.delete(importer);
      cache.set(importer, exist);
      if (!exist) return undefined;
    } else if (fileNames.indexOf(importer) === -1) {
      if (cache.size === 1 << 8) cache.delete(cache.keys().next().value);
      cache.set(importer, false);
      return undefined;
    } else {
      if (cache.size === 1 << 8) cache.delete(cache.keys().next().value);
      cache.set(importer, true);
    }

    return resolveModuleName({
      compilerOptions,
      host,
      importer,
      request,
      mappings,
      falllback
    });
  }, undefined);
}

function register({
  tsConfigPath,
  respectCoreModule,
  logLevel,
  colors,
  loggerID,
  falllback
} = {}) {
  const log = createLogger({
    logLevel: convertLogLevel(logLevel),
    colors,
    ID: loggerID
  });
  const handler = createHandler({
    tsConfigPath,
    respectCoreModule,
    log,
    falllback
  });

  if (!handler) {
    return () => {};
  }

  const originalResolveFilename = Module__default["default"]["_resolveFilename"];

  Module__default["default"]["_resolveFilename"] = function (request, parent, ...args) {
    if (!parent) return originalResolveFilename.apply(this, arguments);
    const moduleName = handler(request, parent.filename);

    if (moduleName) {
      log(exports.LogLevel.Debug, `${request} -> ${moduleName}`);
      return originalResolveFilename.apply(this, [moduleName, parent, ...args]);
    }

    return originalResolveFilename.apply(this, arguments);
  };

  return () => {
    Module__default["default"]["_resolveFilename"] = originalResolveFilename;
  };
}

exports.convertLogLevel = convertLogLevel;
exports.createHandler = createHandler;
exports.createLogger = createLogger;
exports.createMappings = createMappings;
exports.findMatch = findMatch;
exports.fromTS_NODE_PROJECT = fromTS_NODE_PROJECT;
exports.fromTYPESCRIPT_PATHS_LOG_LEVEL = fromTYPESCRIPT_PATHS_LOG_LEVEL;
exports.getTsConfig = getTsConfig;
exports.isPatternMatch = isPatternMatch;
exports.register = register;
exports.resolveModuleName = resolveModuleName;
